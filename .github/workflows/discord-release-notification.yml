name: Discord Release Notification

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag de la release (ex: v1.0.0)'
        required: true
        default: 'v1.0.0'

jobs:
  notify-discord:
    name: Notify Discord
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Extract Version
        id: version
        run: |
          # Utiliser le tag de l'√©v√©nement release ou l'input manuel
          if [ "${{ github.event_name }}" == "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="${{ github.event.inputs.tag_name }}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version_number=${VERSION#v}" >> $GITHUB_OUTPUT

      - name: Extract Changelog
        id: changelog
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          VERSION_NUM="${VERSION#v}"
          
          echo "üîç Extraction du changelog pour la version: $VERSION_NUM"
          
          # Extraire la section du CHANGELOG pour cette version
          # Format attendu: ## [X.Y.Z] - YYYY-MM-DD
          awk -v ver="$VERSION_NUM" '
            /^## \[/ {
              # Extraire la version entre crochets
              if (match($0, /\[([0-9]+\.[0-9]+\.[0-9]+[^\]]*)\]/, arr)) {
                if (arr[1] == ver) {
                  started = 1
                  next
                } else if (started) {
                  exit
                }
              }
            }
            started && /^## \[/ { exit }
            started { print }
          ' CHANGELOG.md > changelog_extract.txt
          
          # V√©rifier si le changelog a √©t√© extrait
          if [ ! -s changelog_extract.txt ]; then
            echo "‚ö†Ô∏è ATTENTION: Changelog vide pour $VERSION_NUM" >&2
            echo "üìù Nouvelles fonctionnalit√©s et corrections de bugs." > changelog_extract.txt
          else
            echo "‚úÖ Changelog extrait ($(wc -l < changelog_extract.txt) lignes)"
          fi
          
          # Limiter √† 900 caract√®res pour laisser de la marge (Discord limite √† 1024)
          CHANGELOG_SIZE=$(wc -c < changelog_extract.txt)
          echo "üìè Taille du changelog: $CHANGELOG_SIZE caract√®res"
          
          if [ $CHANGELOG_SIZE -gt 900 ]; then
            head -c 897 changelog_extract.txt > changelog_short.txt
            echo "..." >> changelog_short.txt
            echo "truncated=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Changelog tronqu√© √† 900 caract√®res"
          else
            cp changelog_extract.txt changelog_short.txt
            echo "truncated=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract Summary
        id: summary
        run: |
          echo "üîç Extraction du r√©sum√©..."
          
          # Extraire les 3 premi√®res cat√©gories principales
          SUMMARY=$(awk '
            /^### / {
              if (count++ < 3) {
                gsub(/^### /, "");
                print "‚Ä¢ " $0
              }
            }
          ' changelog_extract.txt)
          
          # Limiter √† 400 caract√®res pour le summary
          if [ -n "$SUMMARY" ]; then
            SUMMARY=$(echo "$SUMMARY" | head -c 400)
            echo "‚úÖ R√©sum√© extrait: ${#SUMMARY} caract√®res"
          else
            SUMMARY="‚ú® Nouvelles fonctionnalit√©s et am√©liorations"
            echo "‚ö†Ô∏è R√©sum√© par d√©faut utilis√©"
          fi
          
          # Sauvegarder dans un fichier
          echo "$SUMMARY" > summary.txt

      - name: Fetch Release Asset
        id: asset
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          VERSION_NUMBER="${{ steps.version.outputs.version_number }}"
          REPO="${{ github.repository }}"
          
          echo "üîç Recherche des assets pour $VERSION..."
          
          RESPONSE=$(curl -s \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/$REPO/releases/tags/$VERSION")
          
          # Chercher l'installateur .exe
          ASSET_URL=$(echo "$RESPONSE" | jq -r '.assets[]? | select(.name | endswith(".exe")) | .browser_download_url' | head -n 1)
          ASSET_NAME=$(echo "$RESPONSE" | jq -r '.assets[]? | select(.name | endswith(".exe")) | .name' | head -n 1)
          
          # Fallback si l'asset n'existe pas encore
          if [ -z "$ASSET_URL" ] || [ "$ASSET_URL" = "null" ]; then
            echo "‚ö†Ô∏è Asset .exe non trouv√©, utilisation du nom par d√©faut"
            ASSET_NAME="Nexus-$VERSION_NUMBER.exe"
            ASSET_URL="https://github.com/$REPO/releases/download/$VERSION/$ASSET_NAME"
            echo "asset_exists=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Asset trouv√©: $ASSET_NAME"
            echo "asset_exists=true" >> $GITHUB_OUTPUT
          fi
          
          echo "download_url=$ASSET_URL" >> $GITHUB_OUTPUT
          echo "asset_name=$ASSET_NAME" >> $GITHUB_OUTPUT

      - name: Prepare Discord Payload
        id: payload
        env:
          VERSION: ${{ steps.version.outputs.version }}
          VERSION_NUMBER: ${{ steps.version.outputs.version_number }}
          ASSET_URL: ${{ steps.asset.outputs.download_url }}
          ASSET_EXISTS: ${{ steps.asset.outputs.asset_exists }}
          TRUNCATED: ${{ steps.changelog.outputs.truncated }}
        run: |
          # Lire les fichiers
          CHANGELOG_RAW=$(cat changelog_short.txt)
          SUMMARY_RAW=$(cat summary.txt)
          
          # V√©rifier que les fichiers ne sont pas vides
          if [ -z "$CHANGELOG_RAW" ] || [ "$CHANGELOG_RAW" = "" ]; then
            CHANGELOG_RAW="üìù Contenu disponible dans les prochaines releases."
          fi
          
          if [ -z "$SUMMARY_RAW" ] || [ "$SUMMARY_RAW" = "" ]; then
            SUMMARY_RAW="‚ú® Nouvelles fonctionnalit√©s et am√©liorations"
          fi
          
          # Limiter la longueur des champs (Discord limite √† 1024 caract√®res par field value)
          # On limite √† 900 pour avoir de la marge
          
          # Summary : max 400 caract√®res
          if [ ${#SUMMARY_RAW} -gt 400 ]; then
            SUMMARY_RAW="${SUMMARY_RAW:0:397}..."
            echo "‚ö†Ô∏è Summary tronqu√© √† 400 caract√®res"
          fi
          
          # Changelog : max 900 caract√®res
          if [ ${#CHANGELOG_RAW} -gt 900 ]; then
            CHANGELOG_RAW="${CHANGELOG_RAW:0:897}..."
            echo "‚ö†Ô∏è Changelog tronqu√© √† 900 caract√®res"
          fi
          
          echo "üìè Tailles finales:"
          echo "   Summary: ${#SUMMARY_RAW} caract√®res"
          echo "   Changelog: ${#CHANGELOG_RAW} caract√®res"
          
          # Pr√©parer le message de t√©l√©chargement
          if [ "$ASSET_EXISTS" = "true" ]; then
            DOWNLOAD_MSG="**Windows** : [üíæ T√©l√©charger l'installateur]($ASSET_URL)"
          else
            DOWNLOAD_MSG="**Windows** : ‚è≥ L'installateur sera disponible sous peu\n[üì¶ Voir la page de release](https://github.com/Rory-Mercury-91/Le-Nexus/releases/tag/$VERSION)"
          fi
          
          # Ajouter un lien vers le changelog complet si tronqu√© (mais limiter la longueur totale)
          if [ "$TRUNCATED" = "true" ]; then
            CHANGELOG_WITH_LINK="${CHANGELOG_RAW}\n\n_[üìñ Voir le changelog complet](https://github.com/Rory-Mercury-91/Le-Nexus/blob/main/CHANGELOG.md)_"
            # S'assurer que le total ne d√©passe pas 1024
            if [ ${#CHANGELOG_WITH_LINK} -gt 1024 ]; then
              # Tronquer le changelog pour laisser de la place au lien
              MAX_CHANGELOG=$((1024 - 100))
              CHANGELOG_RAW="${CHANGELOG_RAW:0:$MAX_CHANGELOG}..."
              CHANGELOG_WITH_LINK="${CHANGELOG_RAW}\n\n_[üìñ Voir le changelog complet](https://github.com/Rory-Mercury-91/Le-Nexus/blob/main/CHANGELOG.md)_"
            else
              CHANGELOG_RAW="$CHANGELOG_WITH_LINK"
            fi
          fi
          
          # Construire le JSON avec jq (√©chapper correctement les caract√®res sp√©ciaux)
          jq -n \
            --arg username "Nexus Release Bot" \
            --arg avatar "https://github.com/Rory-Mercury-91.png" \
            --arg version "$VERSION" \
            --arg version_num "$VERSION_NUMBER" \
            --arg summary "$SUMMARY_RAW" \
            --arg changelog "$CHANGELOG_RAW" \
            --arg download "$DOWNLOAD_MSG" \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)" \
            '{
              "username": $username,
              "avatar_url": $avatar,
              "embeds": [{
                "title": ("üöÄ Nexus " + $version + " - Nouvelle Version Disponible !"),
                "description": "**Une mise √† jour importante de Nexus est maintenant disponible.**\n\n",
                "color": 5814783,
                "fields": [
                  {
                    "name": "‚ú® Points Cl√©s de cette Version",
                    "value": $summary,
                    "inline": false
                  },
                  {
                    "name": "üìã Changements Complets",
                    "value": $changelog,
                    "inline": false
                  },
                  {
                    "name": "‚¨áÔ∏è T√©l√©chargements",
                    "value": $download,
                    "inline": false
                  },
                  {
                    "name": "üîó Liens Utiles",
                    "value": ("üì¶ [Page de la Release](https://github.com/Rory-Mercury-91/Le-Nexus/releases/tag/" + $version + ")\nüêõ [Signaler un Bug](https://github.com/Rory-Mercury-91/Le-Nexus/issues)\nüìñ [Documentation](https://github.com/Rory-Mercury-91/Le-Nexus#readme)"),
                    "inline": false
                  }
                ],
                "footer": {
                  "text": ("Nexus v" + $version_num + " ‚Ä¢ Production Ready ‚Ä¢ Merci de votre soutien !"),
                  "icon_url": $avatar
                },
                "timestamp": $timestamp
              }]
            }' > discord_payload.json
          
          # Valider le JSON
          if ! jq empty discord_payload.json 2>/dev/null; then
            echo "‚ùå Erreur: Le JSON g√©n√©r√© est invalide"
            cat discord_payload.json
            exit 1
          fi
          
          # Afficher la taille des champs pour debugging
          echo "üìä Tailles des champs:"
          echo "   Summary: ${#SUMMARY_RAW} caract√®res"
          echo "   Changelog: ${#CHANGELOG_RAW} caract√®res"
          echo "   Download: ${#DOWNLOAD_MSG} caract√®res"
          
          echo "‚úÖ Payload Discord pr√©par√© et valid√©"

      - name: Send Discord Notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL_NEXUS }}
        run: |
          echo "üì§ Envoi de la notification Discord..."
          
          # V√©rifier que le webhook est d√©fini
          if [ -z "$DISCORD_WEBHOOK" ] || [ "$DISCORD_WEBHOOK" = "" ]; then
            echo "‚ö†Ô∏è DISCORD_WEBHOOK_URL_NEXUS n'est pas d√©fini, notification ignor√©e"
            exit 0
          fi
          
          # Afficher un aper√ßu du payload (sans les d√©tails sensibles)
          echo "üìã Aper√ßu du payload:"
          jq '{username, embeds: [.embeds[0] | {title, description, fields: [.fields[] | {name, value: (.value | length | "\(.) caract√®res")}]}]}' discord_payload.json
          
          # Envoyer la requ√™te avec gestion d'erreur am√©lior√©e
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$DISCORD_WEBHOOK" \
            -H "Content-Type: application/json" \
            -d @discord_payload.json 2>&1)
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | head -n -1)
          
          if [ "$HTTP_CODE" -eq 204 ] || [ "$HTTP_CODE" -eq 200 ]; then
            echo "‚úÖ Notification envoy√©e avec succ√®s !"
          else
            echo "‚ùå Erreur lors de l'envoi (HTTP $HTTP_CODE)"
            echo "üìã R√©ponse compl√®te:"
            echo "$RESPONSE_BODY"
            
            # Afficher le payload pour debugging
            echo ""
            echo "üìã Payload envoy√©:"
            cat discord_payload.json | jq .
            
            # Si c'est une erreur 400, v√©rifier les limites Discord
            if [ "$HTTP_CODE" -eq 400 ]; then
              echo ""
              echo "üí° Erreur 400 - V√©rifications:"
              echo "   - Les field values doivent √™tre ‚â§ 1024 caract√®res"
              echo "   - L'embed total doit √™tre ‚â§ 6000 caract√®res"
              echo "   - Le JSON doit √™tre valide"
              echo "   - Les caract√®res sp√©ciaux doivent √™tre correctement √©chapp√©s"
            fi
            
            exit 1
          fi
